# When two physics objects are near each other they will both
# eventually be checked for collision aginst each other. This
# collision should only happen once since the effect is applied
# to both at that moment (and it would be faster to skip
# the duplicate collision check).
#
# When one of the two close to each other objects
# are found to be colliding, their IDs (that this script
# shows how to generate) should be put into a `pairing function`
# to generate a uniue index into an array where the value
# at the index is `1` for `this pair already collided` and
# `0` for `this pair has not collided yet`


# Unique IDs:
#   Although the momory address of the physics objec could
#   be used as an ID, those numbers are too big and random.
#   Instead, we'll generate the physics IDs up to a certain
#   maximum but also need to track deleted IDs and assign
#   them to new ones. To do this, we need 1 buffer that
#   holds all the possible IDs at the start (1 -> 255)
#   and dishes them out when needed.
global available_ids;
global next_available_id;
global id_max

id_max = 128;
available_ids = 1:1:id_max; # All IDs that can be assigned (limited to 255-1=254 nodes then)
next_available_id = 1;      # Index into `available_ids` for the next ID that can be assigned
                            # to a node. On providing an ID to a node, this is incremented, on
                            # a node being deleted this is decremented and the value at the
                            # new decremented index is set to the ID of the deleting node


function id = get_available_id()
    global available_ids;
    global next_available_id;
    global id_max

    # Check that we still have IDs to give out
    assert(next_available_id != id_max)

    id = available_ids(next_available_id);
    next_available_id = next_available_id + 1;
end


function none = put_id(id)
    global available_ids;
    global next_available_id;

    next_available_id = next_available_id - 1;
    available_ids(next_available_id) = id;
end

id1 = get_available_id()
id2 = get_available_id()
id3 = get_available_id()
id4 = get_available_id()
id5 = get_available_id()

# Expect these to be the following ID values
assert(id1 == 1)
assert(id2 == 2)
assert(id3 == 3)
assert(id4 == 4)
assert(id5 == 5)

# Put id3 back and check the next two IDs
put_id(id3);
id_check1 = get_available_id()
id_check2 = get_available_id()

assert(id_check1 == 3)
assert(id_check2 == 6)



# Checking IDs for collision:
#   Now that we can generate unqiue IDs in a certain range and they
#   can all be reused, need a way of combining two IDs with values
#   up to `id_max` for a output unique index. This is called a
#   pairing function (https://math.stackexchange.com/a/23506).

all_possible_indices = [];

for a_id = 1:1:id_max
    for b_id = 1:1:id_max
        # Changing `id_max` to anything less then itself results
        # in `length(all_possible_indices_unique)` being different
        # than `length(all_possible_indices)` later, which is bad.
        # We don't want any repeated values that might be removed
        # from `all_possible_indices` using `unique`.
        # https://math.stackexchange.com/a/531914
        all_possible_indices(end+1) = id_max*a_id + b_id;
    end
end

# Try to sort/remove duplicates inside `all_possible_indices`
# and then check the length. The goal is to not generate any
# duplicate indices/outputs for a pair of non-negative integers
all_possible_indices_unique = unique(all_possible_indices);
length_all_possible_indices = length(all_possible_indices)
length_all_possible_indices_unique = length(all_possible_indices_unique)
assert(length_all_possible_indices == length_all_possible_indices_unique)

id_max_index = id_max*id_max + id_max;
printf("The max index that can be generated by id_max*a + b is id_max*id_max + id_max=%.03f , %d/8 = %.03f bytes will be required for an id_max = %d \n", id_max*id_max+id_max, id_max_index, id_max_index/8, id_max)
